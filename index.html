<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Messenger Chat</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<style>
/* --- Visuals unchanged from your preferred UI --- */
body{
  margin:0;
  min-height:100vh;
  display:flex;
  justify-content:center;
  align-items:center;
  background:linear-gradient(135deg,#0f0c29,#302b63,#24243e);
  font-family:'Inter',sans-serif;
  color:white;
}

/* .box layout kept the same, with vertical-centering helpers applied to name/room screens */
.box{
  width:420px;
  max-width:95%;
  background:rgba(255,255,255,0.06);
  backdrop-filter:blur(12px);
  border-radius:20px;
  box-shadow:0 0 40px rgba(0,0,0,.45);
  padding:18px;
  display:flex;
  flex-direction:column;
  height:90vh;
  overflow:hidden;
  justify-content:space-between;
}

/* center content vertically for specific screens */
.center-screen { justify-content:center; align-items:center; gap:12px; }

.topbar{text-align:center;font-weight:600;margin-bottom:8px;}
input,button{
  padding:12px;
  border-radius:12px;
  border:none;
  outline:none;
  margin:6px 0;
  font-size:15px;
}
input{
  background:rgba(255,255,255,0.14);
  color:#fff;
  width:100%;
}
button{
  background:linear-gradient(135deg,#00f2fe,#4facfe);
  color:black;
  font-weight:600;
  cursor:pointer;
}

/* chat area: hidden scrollbar but scrollable */
.chat{
  flex:1;
  overflow-y:auto;
  margin:10px 0;
  display:flex;
  flex-direction:column;
  gap:6px;
  scroll-behavior:smooth;
  scrollbar-width:none; /* firefox */
  -ms-overflow-style:none; /* IE/Edge */
}
.chat::-webkit-scrollbar{ width:0; background:transparent; } /* chrome/safari */

/* messages */
.msg{
  max-width:75%;
  padding:10px 14px;
  border-radius:16px;
  word-break:break-word;
  animation:pop .15s ease;
}
@keyframes pop{ from{opacity:0;transform:translateY(8px);} to{opacity:1;transform:translateY(0);} }

.left{ align-self:flex-start; background:rgba(255,255,255,.2); }
.right{ align-self:flex-end; background:linear-gradient(135deg,#43e97b,#38f9d7); color:black; }

.small{ font-size:12px; opacity:.8; text-align:center; margin-top:3px; }
.row{ display:flex; gap:8px; align-items:center; }
.hidden{ display:none; }

.file-msg{
  background:rgba(255,255,255,.1);
  padding:10px;
  border-radius:12px;
  margin-top:6px;
}
.file-msg img, .file-msg video, .file-msg iframe{
  width:100%;
  border-radius:10px;
}
.file-msg a{
  display:inline-block;
  margin-top:6px;
  padding:6px 10px;
  border-radius:8px;
  background:linear-gradient(135deg,#00f2fe,#4facfe);
  color:black;
  text-decoration:none;
  font-weight:600;
}

/* modal /bibr */
.modal-bg{
  position:fixed; inset:0;
  background:rgba(0,0,0,.55);
  display:flex; align-items:center; justify-content:center; z-index:1000;
}
.modal{
  width:320px; max-width:90%;
  background:#0f1724; padding:18px; border-radius:14px; text-align:center;
}
.modal button, .modal input{ width:100%; margin:6px 0; }

/* call window */
.call-window{
  position:fixed; bottom:10px; right:10px;
  width:250px; background:#0b111a; padding:10px; border-radius:12px; display:flex; flex-direction:column; align-items:center; gap:8px; z-index:1100;
}
.call-window video{ width:100%; border-radius:10px; }
.call-controls{ display:flex; gap:6px; }
.call-controls button{ padding:6px 10px; border-radius:8px; cursor:pointer; }

/* footer */
.footer{ position:fixed; bottom:5px; width:100%; text-align:center; color:#aaa; font-size:12px; pointer-events:none; }

/* small responsive tweak */
@media (max-width:480px){
  .box{ width:92%; height:92vh; padding:14px; }
  .call-window{ right:8px; left:8px; width:auto; }
}
</style>
</head>
<body>

<!-- NAME SCREEN -->
<div class="box center-screen" id="nameScreen">
  <div class="topbar">Your Name</div>
  <input id="username" placeholder="Enter your name">
  <button onclick="next()">Continue</button>
</div>

<!-- ROOM SCREEN -->
<div class="box center-screen hidden" id="roomScreen">
  <div class="topbar">Join or Create Room</div>
  <input id="roomCode" placeholder="Room Code">
  <div style="display:flex;gap:8px;width:100%;">
    <button style="flex:1" onclick="createRoom()">Create Room</button>
    <button style="flex:1" onclick="joinRoom()">Join Room</button>
  </div>
  <div id="error" class="small" style="color:#ff7675"></div>
</div>

<!-- CHAT SCREEN -->
<div class="box hidden" id="chatScreen" style="justify-content:space-between;">
  <div class="topbar">Chat Room</div>
  <div class="small" id="users">Online: â€”</div>

  <div class="chat" id="messages"></div>

  <div class="row" style="margin-top:6px">
    <input id="text" placeholder="Type message..." style="flex:1">
    <button onclick="send()">âž¤</button>
  </div>
</div>

<!-- modal /bibr -->
<div id="modalRoot"></div>
<!-- call window root -->
<div id="callRoot"></div>

<div class="footer">Created by Shujal Khanal</div>

<script>
/* ========= State & helpers ========= */
let ws = null;
let username = "";
let room = "";
let peer = null;
let localStream = null;
const rendered = new Set(); // dedupe messages

function el(id){ return document.getElementById(id); }
function escapeHtml(s){ return String(s||"").replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[m])); }

/* ======= Flow screens ======= */
function next(){
  const v = el("username").value.trim();
  if(!v) return alert("Enter name");
  username = v;
  el("nameScreen").classList.add("hidden");
  el("roomScreen").classList.remove("hidden");
}

function createRoom(){
  room = Math.random().toString(36).substr(2,6).toUpperCase();
  connect("create");
  // show code modal so user can copy
  showRoomCode(room);
}

function joinRoom(){
  const v = el("roomCode").value.trim().toUpperCase();
  if(!v) return alert("Enter room code");
  room = v;
  connect("join");
}

/* ======= WebSocket & message handling ======= */
function connect(type){
ws = new WebSocket("wss://" + location.host);


  ws.onopen = () => {
    ws.send(JSON.stringify({ type, room, username }));
  };

  ws.onmessage = async (e) => {
    let data;
    try{ data = JSON.parse(e.data); } catch { return; }

    if(data.type === "error"){ el("error").innerText = data.text; return; }
    if(data.type === "created" || data.type === "joined"){
      el("roomScreen").classList.add("hidden");
      el("chatScreen").classList.remove("hidden");
    }
    if(data.type === "users"){
      el("users").innerText = "Online: " + (data.users && data.users.length ? data.users.join(", ") : "â€”");
    }

    if(data.type === "message"){
      if(!rendered.has(data.message.id)){
        rendered.add(data.message.id);
        addMessageToUI(data.message);
      }
    }

    if(data.type === "file"){
      if(!rendered.has(data.message.id)){
        rendered.add(data.message.id);
        addFileToUI(data.message);
      }
    }

    if(data.type === "delete"){
      const elm = document.querySelector(`[data-id='${data.id}']`);
      if(elm){ elm.remove(); rendered.delete(data.id); }
    }

    if(data.type === "clear"){
      el("messages").innerHTML = "";
      rendered.clear();
    }

    /* WebRTC signaling messages */
    if(data.type === "call-request"){
      showIncomingCall(data.from, !!data.video);
    }
    if(data.type === "offer"){
      await handleOffer(data.offer, data.from);
    }
    if(data.type === "answer"){
      await handleAnswer(data.answer);
    }
    if(data.type === "candidate"){
      if(peer) peer.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(()=>{});
    }
    if(data.type === "call-end"){
      endCall();
    }
  };

  ws.onclose = () => {
    // silent; user can reconnect by refreshing or creating/joining again
  };
}

/* ======= UI renderers ======= */
function addMessageToUI(m){
  const d = document.createElement("div");
  d.className = "msg " + (m.sender === username ? "right" : "left");
  d.dataset.id = m.id;
  d.innerHTML = `<b>${escapeHtml(m.sender)}</b><br>${escapeHtml(m.text)}`;
  el("messages").appendChild(d);
  el("messages").scrollTop = el("messages").scrollHeight;
}

function addFileToUI(m){
  const d = document.createElement("div");
  d.className = "msg " + (m.sender === username ? "right" : "left");
  d.dataset.id = m.id;

  let preview = "";
  if(m.filetype && m.filetype.startsWith("image/")){
    preview = `<img src="${m.data}" alt="${escapeHtml(m.name)}">`;
  } else if(m.filetype && m.filetype.startsWith("video/")){
    preview = `<video controls src="${m.data}"></video>`;
  } else if(m.filetype && m.filetype.startsWith("audio/")){
    preview = `<audio controls src="${m.data}"></audio>`;
  } else if(m.filetype === "application/pdf"){
    preview = `<iframe src="${m.data}" style="height:200px;border:none;border-radius:8px;"></iframe>`;
  } else {
    preview = `<div style="padding:8px;border-radius:8px;background:rgba(255,255,255,0.03)">File: ${escapeHtml(m.name)}</div>`;
  }

  d.innerHTML = `<b>${escapeHtml(m.sender)}</b>
    <div class="file-msg">
      ${preview}
      <a href="${m.data}" download="${escapeHtml(m.name)}">Download</a>
    </div>`;

  el("messages").appendChild(d);
  el("messages").scrollTop = el("messages").scrollHeight;
}

/* ======= Sending messages & commands ======= */
function send(){
  const t = el("text").value.trim();
  if(!t) return;

  // secret commands:
  if(t === "/bibr"){
    openBibrModal(); el("text").value = ""; return;
  }
  if(t === "/clear"){
    if(ws && ws.readyState === 1) ws.send(JSON.stringify({ type: "clear" }));
    el("text").value = ""; return;
  }

  if(ws && ws.readyState === 1){
    ws.send(JSON.stringify({ type: "message", text: t }));
  } else {
    alert("Not connected to a room. Create or join a room first.");
  }
  el("text").value = "";
}

el("text").addEventListener("keydown", e => {
  if(e.key === "Enter"){ e.preventDefault(); send(); }
});

/* ======= /bibr modal: file + call (keeps original look) ======= */
function openBibrModal(){
  el("modalRoot").innerHTML = `
    <div class="modal-bg" id="bibrBackdrop">
      <div class="modal">
        <h3>Actions</h3>
        <button id="b_audio">ðŸŽ¤ Audio Call</button>
        <button id="b_video">ðŸ“¹ Video Call</button>
        <input type="file" id="b_file" />
        <button id="b_sendfile">Send File</button>
        <button id="b_close">Close</button>
      </div>
    </div>
  `;
  document.getElementById("b_close").onclick = closeBibrModal;
  document.getElementById("b_audio").onclick = ()=>{ requestCall(false); closeBibrModal(); };
  document.getElementById("b_video").onclick = ()=>{ requestCall(true); closeBibrModal(); };
  document.getElementById("b_sendfile").onclick = bibrSendFile;
}

function closeBibrModal(){ el("modalRoot").innerHTML = ""; }

function bibrSendFile(){
  const f = document.getElementById("b_file").files[0];
  if(!f) return alert("Choose file");
  if(f.size > 50 * 1024 * 1024) return alert("File too large (max 50MB)");
  const r = new FileReader();
  r.onload = () => {
    if(ws && ws.readyState === 1){
      ws.send(JSON.stringify({ type: "file", name: f.name, data: r.result, filetype: f.type }));
      closeBibrModal();
    } else alert("Not connected");
  };
  r.readAsDataURL(f);
}

/* ======= ROOM CODE modal ======= */
function showRoomCode(code){
  el("modalRoot").innerHTML = `
    <div class="modal-bg">
      <div class="modal">
        <h3>Room Code</h3>
        <div style="font-size:20px;letter-spacing:2px;margin:8px 0">${escapeHtml(code)}</div>
        <button id="copyCode">Copy</button>
        <button id="closeCode">Close</button>
      </div>
    </div>
  `;
  document.getElementById("copyCode").onclick = ()=>{ navigator.clipboard.writeText(code).then(()=>alert("Copied")); };
  document.getElementById("closeCode").onclick = ()=>{ el("modalRoot").innerHTML = ""; };
}

/* ======= CALLS (WebRTC) ======= */

/* Request a call (notify others) */
function requestCall(video){
  if(ws && ws.readyState === 1){
    ws.send(JSON.stringify({ type: "call-request", video: !!video }));
    // caller will wait for offer/answer exchange
    // optionally show small "calling" UI
    showOutgoingCallUI(video);
  } else alert("Not connected");
}

/* Incoming call prompt */
function showIncomingCall(from, video){
  // simple prompt modal
  el("modalRoot").innerHTML = `
    <div class="modal-bg">
      <div class="modal">
        <h3>Incoming ${video ? "Video" : "Audio"} Call</h3>
        <div style="margin:8px 0">From: ${escapeHtml(from)}</div>
        <div style="display:flex;gap:8px">
          <button id="acceptCall">Accept</button>
          <button id="rejectCall">Reject</button>
        </div>
      </div>
    </div>
  `;
  document.getElementById("acceptCall").onclick = async () => {
    el("modalRoot").innerHTML = "";
    await acceptCall(video);
  };
  document.getElementById("rejectCall").onclick = () => {
    if(ws && ws.readyState === 1) ws.send(JSON.stringify({ type: "call-reject" }));
    el("modalRoot").innerHTML = "";
  };
}

/* Caller shows a small UI while waiting */
function showOutgoingCallUI(video){
  el("modalRoot").innerHTML = `
    <div class="modal-bg">
      <div class="modal">
        <h3>Callingâ€¦</h3>
        <p>Please wait</p>
        <button id="cancelCall">Cancel</button>
      </div>
    </div>
  `;
  document.getElementById("cancelCall").onclick = () => {
    if(ws && ws.readyState === 1) ws.send(JSON.stringify({ type: "call-reject" }));
    el("modalRoot").innerHTML = "";
  };
}

/* Accept incoming call: capture media, create RTCPeerConnection, send answer */
async function acceptCall(video){
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: !!video });
  } catch (err){
    alert("Camera/Mic access denied or not available.");
    return;
  }

  // create peer and wait for offer from caller (server will forward)
  createPeerConnection();

  // when we get the offer (server will send it), handleOffer will set remote and create answer
  // show call window (audio/video)
  showCallWindow();
}

/* Create local peer and attach handlers (used for both caller and callee) */
function createPeerConnection(){
  peer = new RTCPeerConnection({
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
  });

  if(localStream){
    for(const tr of localStream.getTracks()) peer.addTrack(tr, localStream);
  }

  peer.onicecandidate = (e) => {
    if(e.candidate && ws && ws.readyState === 1){
      ws.send(JSON.stringify({ type: "candidate", candidate: e.candidate }));
    }
  };

  peer.ontrack = (e) => {
    // show remote stream in call window
    const remoteVid = document.getElementById("remoteVid");
    if(remoteVid) remoteVid.srcObject = e.streams[0];
  };
}

/* When caller initiates, we must create an offer and send it */
async function callerStartCall(video){
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: !!video });
  } catch (err){
    alert("Camera/Mic access denied or not available.");
    return;
  }

  createPeerConnection();

  // show call window
  showCallWindow();

  // create offer and send to server
  const offer = await peer.createOffer();
  await peer.setLocalDescription(offer);
  if(ws && ws.readyState === 1){
    ws.send(JSON.stringify({ type: "offer", offer }));
  }
}

/* If we receive an offer (we are callee) */
async function handleOffer(offer, from){
  // if not created, create peer and get local media (ask user)
  if(!peer){
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
    } catch (err){
      // fallback to audio-only
      try { localStream = await navigator.mediaDevices.getUserMedia({ audio: true }); } catch {}
    }
    createPeerConnection();
    showCallWindow();
  }

  await peer.setRemoteDescription(new RTCSessionDescription(offer));
  const answer = await peer.createAnswer();
  await peer.setLocalDescription(answer);
  if(ws && ws.readyState === 1) ws.send(JSON.stringify({ type: "answer", answer }));
}

/* If caller receives answer */
async function handleAnswer(answer){
  if(peer) await peer.setRemoteDescription(new RTCSessionDescription(answer));
}

/* End call */
function endCall(){
  if(peer){ try{ peer.close(); }catch{} peer = null; }
  if(localStream){ for(const t of localStream.getTracks()){ try{ t.stop(); }catch{} } localStream = null; }
  el("callRoot").innerHTML = "";
  // notify others optionally
  if(ws && ws.readyState === 1) ws.send(JSON.stringify({ type: "call-end" }));
}

/* Show call UI with controls */
function showCallWindow(){
  el("callRoot").innerHTML = `
    <div class="call-window" id="activeCall">
      <video id="remoteVid" autoplay playsinline></video>
      <div class="call-controls">
        <button id="muteBtn">Mute</button>
        <button id="camBtn">Cam</button>
        <button id="hangBtn">Hang Up</button>
      </div>
    </div>
  `;

  document.getElementById("hangBtn").onclick = endCall;
  let muted = false;
  document.getElementById("muteBtn").onclick = () => {
    if(!localStream) return;
    for(const t of localStream.getAudioTracks()) t.enabled = muted;
    muted = !muted;
    document.getElementById("muteBtn").innerText = muted ? "Unmute" : "Mute";
  };
  let camOff = false;
  document.getElementById("camBtn").onclick = () => {
    if(!localStream) return;
    for(const t of localStream.getVideoTracks()) t.enabled = camOff;
    camOff = !camOff;
    document.getElementById("camBtn").innerText = camOff ? "Cam On" : "Cam";
  };

  // if we have local stream and local video elements are wanted, show small local preview (not altering main UI)
  // optional: show local preview inside call window (skipped to avoid UI change)
}

/* ======= File drag & paste quick helper (optional) ======= */
/* You asked not to change UI: we do not add visible UI; but supporting drag/paste keeps UX */
document.addEventListener('paste', (e) => {
  // paste handling: if clipboard contains files (images), send as file
  const items = (e.clipboardData || e.originalEvent.clipboardData).items;
  for (const item of items) {
    if (item.kind === 'file') {
      const f = item.getAsFile();
      if(f){
        const r = new FileReader();
        r.onload = () => { if(ws && ws.readyState === 1) ws.send(JSON.stringify({ type: "file", name: f.name, data: r.result, filetype: f.type })); };
        r.readAsDataURL(f);
      }
    }
  }
});

/* ======= Utilities ======= */
function show(el){ el.classList.remove('hidden'); }
function hide(el){ el.classList.add('hidden'); }

/* small safety: ensure DOM elements referenced exist */
const nameScreen = el("nameScreen"), roomScreen = el("roomScreen"), chatScreen = el("chatScreen"),
      messages = el("messages"), modalRoot = el("modalRoot"), callRoot = el("callRoot");

</script>
</body>
</html>



